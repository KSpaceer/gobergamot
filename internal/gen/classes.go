// Code generated by wazero-emscripten-embind, DO NOT EDIT.
package gen

import (
	"context"

	"github.com/jerbob92/wazero-emscripten-embind"
)

type ClassAlignedMemory struct {
	embind.ClassBase
}

func (class *ClassAlignedMemory) Clone(ctx context.Context) (*ClassAlignedMemory, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassAlignedMemory), nil
}

func (class *ClassAlignedMemory) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassAlignedMemory) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassAlignedMemory) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassAlignedMemory) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassAlignedMemory) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassAlignedMemory) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassAlignedMemory) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassAlignedMemory) GetByteArrayView(ctx context.Context) (any, error) {
	res, err := class.CallMethod(ctx, "getByteArrayView")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassAlignedMemory) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassAlignedMemory(e embind.Engine, ctx context.Context, arg0 uint32, arg1 uint32) (*ClassAlignedMemory, error) {
	res, err := e.CallPublicSymbol(ctx, "AlignedMemory", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassAlignedMemory), nil
}

type ClassAlignedMemoryList struct {
	embind.ClassBase
}

func (class *ClassAlignedMemoryList) Clone(ctx context.Context) (*ClassAlignedMemoryList, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassAlignedMemoryList), nil
}

func (class *ClassAlignedMemoryList) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassAlignedMemoryList) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassAlignedMemoryList) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassAlignedMemoryList) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassAlignedMemoryList) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassAlignedMemoryList) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassAlignedMemoryList) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassAlignedMemoryList) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassAlignedMemoryList) Push_back(ctx context.Context, arg0 embind.ClassBase) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassAlignedMemoryList) Resize(ctx context.Context, arg0 uint32, arg1 embind.ClassBase) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassAlignedMemoryList) Set(ctx context.Context, arg0 uint32, arg1 embind.ClassBase) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassAlignedMemoryList) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassAlignedMemoryList(e embind.Engine, ctx context.Context) (*ClassAlignedMemoryList, error) {
	res, err := e.CallPublicSymbol(ctx, "AlignedMemoryList")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassAlignedMemoryList), nil
}

type ClassBlockingService struct {
	embind.ClassBase
}

func (class *ClassBlockingService) Clone(ctx context.Context) (*ClassBlockingService, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassBlockingService), nil
}

func (class *ClassBlockingService) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassBlockingService) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassBlockingService) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassBlockingService) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassBlockingService) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassBlockingService) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassBlockingService) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassBlockingService) Translate(ctx context.Context, arg0 embind.ClassBase, arg1 embind.ClassBase, arg2 embind.ClassBase) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "translate", arg0, arg1, arg2)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassBlockingService) TranslateViaPivoting(ctx context.Context, arg0 embind.ClassBase, arg1 embind.ClassBase, arg2 embind.ClassBase, arg3 embind.ClassBase) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "translateViaPivoting", arg0, arg1, arg2, arg3)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func NewClassBlockingService(e embind.Engine, ctx context.Context, arg0 map[string]any) (*ClassBlockingService, error) {
	res, err := e.CallPublicSymbol(ctx, "BlockingService", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassBlockingService), nil
}

type ClassResponse struct {
	embind.ClassBase
}

func (class *ClassResponse) Clone(ctx context.Context) (*ClassResponse, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassResponse), nil
}

func (class *ClassResponse) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassResponse) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassResponse) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassResponse) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassResponse) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassResponse) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassResponse) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassResponse) GetOriginalText(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getOriginalText")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassResponse) GetSourceSentence(ctx context.Context, arg0 uint32) (map[string]any, error) {
	res, err := class.CallMethod(ctx, "getSourceSentence", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(map[string]any), nil
}

func (class *ClassResponse) GetTranslatedSentence(ctx context.Context, arg0 uint32) (map[string]any, error) {
	res, err := class.CallMethod(ctx, "getTranslatedSentence", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(map[string]any), nil
}

func (class *ClassResponse) GetTranslatedText(ctx context.Context) (string, error) {
	res, err := class.CallMethod(ctx, "getTranslatedText")
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassResponse) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassResponse(e embind.Engine, ctx context.Context) (*ClassResponse, error) {
	res, err := e.CallPublicSymbol(ctx, "Response")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassResponse), nil
}

type ClassTranslationModel struct {
	embind.ClassBase
}

func (class *ClassTranslationModel) Clone(ctx context.Context) (*ClassTranslationModel, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassTranslationModel), nil
}

func (class *ClassTranslationModel) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassTranslationModel) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassTranslationModel) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassTranslationModel) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassTranslationModel) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassTranslationModel) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassTranslationModel) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func NewClassTranslationModel(e embind.Engine, ctx context.Context, arg0 string, arg1 embind.ClassBase, arg2 embind.ClassBase, arg3 embind.ClassBase, arg4 embind.ClassBase) (*ClassTranslationModel, error) {
	res, err := e.CallPublicSymbol(ctx, "TranslationModel", arg0, arg1, arg2, arg3, arg4)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassTranslationModel), nil
}

type ClassVectorResponse struct {
	embind.ClassBase
}

func (class *ClassVectorResponse) Clone(ctx context.Context) (*ClassVectorResponse, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassVectorResponse), nil
}

func (class *ClassVectorResponse) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassVectorResponse) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassVectorResponse) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassVectorResponse) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassVectorResponse) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassVectorResponse) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassVectorResponse) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassVectorResponse) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassVectorResponse) Push_back(ctx context.Context, arg0 embind.ClassBase) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassVectorResponse) Resize(ctx context.Context, arg0 uint32, arg1 embind.ClassBase) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassVectorResponse) Set(ctx context.Context, arg0 uint32, arg1 embind.ClassBase) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassVectorResponse) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassVectorResponse(e embind.Engine, ctx context.Context) (*ClassVectorResponse, error) {
	res, err := e.CallPublicSymbol(ctx, "VectorResponse")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassVectorResponse), nil
}

type ClassVectorResponseOptions struct {
	embind.ClassBase
}

func (class *ClassVectorResponseOptions) Clone(ctx context.Context) (*ClassVectorResponseOptions, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassVectorResponseOptions), nil
}

func (class *ClassVectorResponseOptions) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassVectorResponseOptions) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassVectorResponseOptions) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassVectorResponseOptions) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassVectorResponseOptions) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassVectorResponseOptions) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassVectorResponseOptions) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassVectorResponseOptions) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassVectorResponseOptions) Push_back(ctx context.Context, arg0 map[string]any) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassVectorResponseOptions) Resize(ctx context.Context, arg0 uint32, arg1 map[string]any) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassVectorResponseOptions) Set(ctx context.Context, arg0 uint32, arg1 map[string]any) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassVectorResponseOptions) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassVectorResponseOptions(e embind.Engine, ctx context.Context) (*ClassVectorResponseOptions, error) {
	res, err := e.CallPublicSymbol(ctx, "VectorResponseOptions")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassVectorResponseOptions), nil
}

type ClassVectorString struct {
	embind.ClassBase
}

func (class *ClassVectorString) Clone(ctx context.Context) (*ClassVectorString, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassVectorString), nil
}

func (class *ClassVectorString) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassVectorString) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassVectorString) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassVectorString) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassVectorString) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassVectorString) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassVectorString) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassVectorString) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassVectorString) Push_back(ctx context.Context, arg0 string) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassVectorString) Resize(ctx context.Context, arg0 uint32, arg1 string) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassVectorString) Set(ctx context.Context, arg0 uint32, arg1 string) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassVectorString) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassVectorString(e embind.Engine, ctx context.Context) (*ClassVectorString, error) {
	res, err := e.CallPublicSymbol(ctx, "VectorString")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassVectorString), nil
}
